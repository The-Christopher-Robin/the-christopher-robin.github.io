1a
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
int main(){
int fd = open("file.txt", O_RDONLY);
int size lseek(fd, 0, SEEK_END);
char ch;
while (size--) {
lseek(fd, size, SEEK_SET);
read (fd, &ch, 1);
putchar(ch);
}
close(fd);
return 0;
}

1b
#include<stdio.h>
#include<fcntl.h>
#include<unistd.h>
#include <sys/wait.h>
int main(){
int fd = open("test.txt", O_RDONLY);
int pid = fork();
char buffer [10];
if(pid == 0) {
read(fd, buffer, 10);
buffer [10]='\0';
printf("Child Process %s\n", buffer);
}else{
wait (NULL);
read(fd, buffer, 10);
buffer [10] = '\0';
printf("Parent read: %s\n", buffer);
}
close(fd);
return 0;
}


2a
#include<stdio.h>
#include<sys/stat.h>
int main(){
struct stat ft;
stat("file.txt",&ft);
printf("size is %ld bytes \n",ft.st_size);
printf("no of links:%ld\n",ft.st_nlink);
printf("access time: %ld\n",ft.st_atime);
printf("file inode: %ld\n",ft.st_ino);
printf("modified time : %ld\n",ft.st_mtime);
return 0;
}

2b
#include <stdio.h>
#include <fcntl.h>
#include<stdlib.h>
void printFlags(int fd) {
int flags = fcntl(fd, F_GETFL);
printf("File flags for descriptor %d:\n", fd);
printf("O_APPEND: %s\n", (flags & O_APPEND) ? "Yes" : "No");
printf("O_NONBLOCK: %s\n", (flags & O_NONBLOCK) ? "Yes" : "No");
printf("O_SYNC: %s\n", (flags & O_SYNC) ? "Yes" : "No");
// Add more flags as needed
}
int main(int argc, char *argv[]) {
if (argc != 2) {
printf("Usage: %s <file descriptor>\n", argv[0]);
return 1;
}
int fd = atoi(argv[1]);
printFlags(fd);
return 0;
}

3a
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main() {
execl("/bin/sh","sh","-c","ls -l",(char *)0);
return 0;
}

3b
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <time.h>
#include<sys/stat.h>
int main(){
	struct dirent *dir;
	struct stat mystat;
	DIR *dp;
	dp = opendir(".");
	if(dp){
		while(dir = readdir(dp)){
			stat(dir->d_name,&mystat);
			printf("%ld %o %d %d %s %s\n",mystat.st_ino,mystat.st_mode,mystat.st_uid,mystat.st_gid,ctime(&mystat.st_atime),dir->d_name);
		}
	}
}

4a
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <filename>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    const char *original_file = argv[1];
    char hard_link[256];
    char soft_link[256];
    struct stat fileStat;

    snprintf(hard_link, sizeof(hard_link), "%s_hardlink", original_file);
    snprintf(soft_link, sizeof(soft_link), "%s_softlink", original_file);

    // Create a file to link to
    int fd = open(original_file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    write(fd, "Hello, World!\n", 14);
    close(fd);

    // Create a hard link
    if (link(original_file, hard_link) < 0) {
        perror("link");
        exit(EXIT_FAILURE);
    }

    // Create a soft link
    if (symlink(original_file, soft_link) < 0) {
        perror("symlink");
        exit(EXIT_FAILURE);
    }

    // Print information about the original file
    printf("Original file info:\n");
    if (stat(original_file, &fileStat) == 0) {
        printf("Inode: %ld\n", (long)fileStat.st_ino);
        printf("Hard link count: %ld\n", (long)fileStat.st_nlink);
        printf("Size: %ld bytes\n", (long)fileStat.st_size);
        printf("Permissions: %o\n", fileStat.st_mode & 0777);
        printf("Last access: %s", ctime(&fileStat.st_atime));
        printf("Last modification: %s", ctime(&fileStat.st_mtime));
        printf("Last status change: %s\n", ctime(&fileStat.st_ctime));
    } else {
        perror("stat");
    }
    
    // Print information about the hard link
    printf("Hard link info:\n");
    if (stat(hard_link, &fileStat) == 0) {
        printf("Inode: %ld\n", (long)fileStat.st_ino);
        printf("Hard link count: %ld\n", (long)fileStat.st_nlink);
        printf("Size: %ld bytes\n", (long)fileStat.st_size);
        printf("Permissions: %o\n", fileStat.st_mode & 0777);
        printf("Last access: %s", ctime(&fileStat.st_atime));
        printf("Last modification: %s", ctime(&fileStat.st_mtime));
        printf("Last status change: %s\n", ctime(&fileStat.st_ctime));
    } else {
        perror("stat");
    }

    // Print information about the soft link
    printf("Soft link info:\n");
    if (lstat(soft_link, &fileStat) == 0) {
        printf("Inode: %ld\n", (long)fileStat.st_ino);
        printf("Hard link count: %ld\n", (long)fileStat.st_nlink);
        printf("Size: %ld bytes\n", (long)fileStat.st_size);
        printf("Permissions: %o\n", fileStat.st_mode & 0777);
        printf("Last access: %s", ctime(&fileStat.st_atime));
        printf("Last modification: %s", ctime(&fileStat.st_mtime));
        printf("Last status change: %s\n", ctime(&fileStat.st_ctime));
    } else {
        perror("lstat");
    }

    // Cleanup
    if (unlink(original_file) < 0) {
        perror("unlink original");
    }
    if (unlink(hard_link) < 0) {
        perror("unlink hard link");
    }
    if (unlink(soft_link) < 0) {
        perror("unlink soft link");
    }

    return 0;
}


4b
4bechoall.c
// echoall.c
#include <stdio.h>

int main(int argc, char *argv[], char *envp[]) {
    printf("Arguments:\n");
    for (int i = 0; i < argc; ++i) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }

    printf("\nEnvironment Variables:\n");
    for (int i = 0; envp[i] != NULL; ++i) {
        printf("envp[%d]: %s\n", i, envp[i]);
    }

    return 0;
}

4binterpreter.sh
#!/bin/sh
# interpreter.sh
./4bechoall "$@"

4bechoall









#include<stdlib.h>
#include<stdio.h>
#include<fcntl.h>
#include<string.h>
#include<sys/stat.h>
#include<unistd.h>
#include<sys/wait.h>
#include <sys/types.h>
#include<time.h>
#include<dirent.h>
#include<utime.h>
#include<signal.h>
#include<errno.h>
#include<setjmp.h>
#include <syslog.h>

10a
cc -o de filename.c
./de
ps -axj

1a.c

```bash
  cc 1a.c
  ./a.out test.txt
```
1b.c

```bash
  cc 1b.c
  ./a.out test.txt
```

2a.c

```bash
  cc 2a.c
  ./a.out test.txt
```

2b.c

```bash
  cc 2b.c
  ./a.out test.txt
```
3a.c

```bash
  cc 3a.c
  ./a.out
```
3b.c

```bash
  cc 3b.c
  ./a.out
```
4a.c

It deletes the text file, hence make test.txt again after execution
```bash
  cc 4a.c
  ./a.out test.txt
```
4b.c

Change the name of interpreter file from 4binterpreter.sh(in 4bmain.c) to as required

Change the name of echoall.c file from 4bechoall.c to as required in interpreter.sh file
```bash
  gcc -o 4bechoall 4bechoall.c
  chmod +x 4binterpreter.sh
  cc 4bmain.c
  ./a.out
```
 5a.c
 
 After calling stat function we can see change parameter displayed is same
 ```bash
  cc 5a.c
  ./a.out test.txt test2.txt
  stat test.txt
  stat test2.txt
```

 5b.c
 
 After calling stat function we can see change parameter displayed is same
 ```bash
  cc 5b.c
  ./a.out
```
 6a.c
 
 Create an empty file in the directory

 Program will delete it(cross check with ls)
 ```bash
  cc 6a.c
  ./a.out
```

6b.c

 ```bash
  cc 6b.c
  ./a.out test3.txt
```
Open a new terminal and then run the program again

```bash
  cc 6b.c
  ./a.out test3.txt
```

7a.c 

```bash
  cc 7a.c
  ./a.out
```

7b.c 

```bash
  cc 7b.c
  ./a.out source.txt destination.txt
```
8a.c is same as 6a.c 

8b.c

Create an example.txt file

```bash
  vi example.txt
  cc 8b.c
  ./a.out
```
9a.c 

Change file names as you want

```bash
  cc 9aumask.c
  ./a.out
  cc 9achmod.c
  ./a.out
```
9b.c 

Create testfile.txt 
```bash
  cc 9b.c
  ./a.out
```

10.a

```bash
  cc 10.c
  ./a.out
```

10.b

```bash
  cc 10.b
  ./a.out
```
